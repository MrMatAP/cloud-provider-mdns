# coding: utf-8

"""
    Kubernetes CRD Swagger

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, field_validator
from typing import Any, ClassVar, Dict, List
from typing_extensions import Annotated
from k8s_gateway_api.models.io_k8s_networking_gateway_v1_gateway_spec_listeners_inner_allowed_routes_kinds_inner import IoK8sNetworkingGatewayV1GatewaySpecListenersInnerAllowedRoutesKindsInner
from k8s_gateway_api.models.io_k8s_networking_gateway_v1_grpc_route_status_parents_inner_conditions_inner import IoK8sNetworkingGatewayV1GRPCRouteStatusParentsInnerConditionsInner
from typing import Optional, Set
from typing_extensions import Self

class IoK8sNetworkingGatewayV1GatewayStatusListenersInner(BaseModel):
    """
    ListenerStatus is the status associated with a Listener.
    """ # noqa: E501
    attached_routes: StrictInt = Field(description="AttachedRoutes represents the total number of Routes that have been successfully attached to this Listener.  Successful attachment of a Route to a Listener is based solely on the combination of the AllowedRoutes field on the corresponding Listener and the Route's ParentRefs field. A Route is successfully attached to a Listener when it is selected by the Listener's AllowedRoutes field AND the Route has a valid ParentRef selecting the whole Gateway resource or a specific Listener as a parent resource (more detail on attachment semantics can be found in the documentation on the various Route kinds ParentRefs fields). Listener or Route status does not impact successful attachment, i.e. the AttachedRoutes field count MUST be set for Listeners with condition Accepted: false and MUST count successfully attached Routes that may themselves have Accepted: false conditions.  Uses for this field include troubleshooting Route attachment and measuring blast radius/impact of changes to a Listener.", alias="attachedRoutes")
    conditions: Annotated[List[IoK8sNetworkingGatewayV1GRPCRouteStatusParentsInnerConditionsInner], Field(max_length=8)] = Field(description="Conditions describe the current condition of this listener.")
    name: Annotated[str, Field(min_length=1, strict=True, max_length=253)] = Field(description="Name is the name of the Listener that this status corresponds to.")
    supported_kinds: Annotated[List[IoK8sNetworkingGatewayV1GatewaySpecListenersInnerAllowedRoutesKindsInner], Field(max_length=8)] = Field(description="SupportedKinds is the list indicating the Kinds supported by this listener. This MUST represent the kinds an implementation supports for that Listener configuration.  If kinds are specified in Spec that are not supported, they MUST NOT appear in this list and an implementation MUST set the \"ResolvedRefs\" condition to \"False\" with the \"InvalidRouteKinds\" reason. If both valid and invalid Route kinds are specified, the implementation MUST reference the valid Route kinds that have been specified.", alias="supportedKinds")
    __properties: ClassVar[List[str]] = ["attachedRoutes", "conditions", "name", "supportedKinds"]

    @field_validator('name')
    def name_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$", value):
            raise ValueError(r"must validate the regular expression /^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$/")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of IoK8sNetworkingGatewayV1GatewayStatusListenersInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in conditions (list)
        _items = []
        if self.conditions:
            for _item_conditions in self.conditions:
                if _item_conditions:
                    _items.append(_item_conditions.to_dict())
            _dict['conditions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in supported_kinds (list)
        _items = []
        if self.supported_kinds:
            for _item_supported_kinds in self.supported_kinds:
                if _item_supported_kinds:
                    _items.append(_item_supported_kinds.to_dict())
            _dict['supportedKinds'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of IoK8sNetworkingGatewayV1GatewayStatusListenersInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "attachedRoutes": obj.get("attachedRoutes"),
            "conditions": [IoK8sNetworkingGatewayV1GRPCRouteStatusParentsInnerConditionsInner.from_dict(_item) for _item in obj["conditions"]] if obj.get("conditions") is not None else None,
            "name": obj.get("name"),
            "supportedKinds": [IoK8sNetworkingGatewayV1GatewaySpecListenersInnerAllowedRoutesKindsInner.from_dict(_item) for _item in obj["supportedKinds"]] if obj.get("supportedKinds") is not None else None
        })
        return _obj



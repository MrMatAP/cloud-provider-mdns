# coding: utf-8

"""
    Kubernetes CRD Swagger

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from k8s_gateway_api.models.io_k8s_networking_gateway_v1_gateway_spec_listeners_inner_allowed_routes import IoK8sNetworkingGatewayV1GatewaySpecListenersInnerAllowedRoutes
from k8s_gateway_api.models.io_k8s_networking_gateway_v1_gateway_spec_listeners_inner_tls import IoK8sNetworkingGatewayV1GatewaySpecListenersInnerTls
from typing import Optional, Set
from typing_extensions import Self

class IoK8sNetworkingGatewayV1GatewaySpecListenersInner(BaseModel):
    """
    Listener embodies the concept of a logical endpoint where a Gateway accepts network connections.
    """ # noqa: E501
    allowed_routes: Optional[IoK8sNetworkingGatewayV1GatewaySpecListenersInnerAllowedRoutes] = Field(default=None, alias="allowedRoutes")
    hostname: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=253)]] = Field(default=None, description="Hostname specifies the virtual hostname to match for protocol types that define this concept. When unspecified, all hostnames are matched. This field is ignored for protocols that don't require hostname based matching.  Implementations MUST apply Hostname matching appropriately for each of the following protocols:  * TLS: The Listener Hostname MUST match the SNI. * HTTP: The Listener Hostname MUST match the Host header of the request. * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP   protocol layers as described above. If an implementation does not   ensure that both the SNI and Host header match the Listener hostname,   it MUST clearly document that.  For HTTPRoute and TLSRoute resources, there is an interaction with the `spec.hostnames` array. When both listener and route specify hostnames, there MUST be an intersection between the values for a Route to be accepted. For more information, refer to the Route specific Hostnames documentation.  Hostnames that are prefixed with a wildcard label (`*.`) are interpreted as a suffix match. That means that a match for `*.example.com` would match both `test.example.com`, and `foo.test.example.com`, but not `example.com`.  Support: Core")
    name: Annotated[str, Field(min_length=1, strict=True, max_length=253)] = Field(description="Name is the name of the Listener. This name MUST be unique within a Gateway.  Support: Core")
    port: Annotated[int, Field(le=65535, strict=True, ge=1)] = Field(description="Port is the network port. Multiple listeners may use the same port, subject to the Listener compatibility rules.  Support: Core")
    protocol: Annotated[str, Field(min_length=1, strict=True, max_length=255)] = Field(description="Protocol specifies the network protocol this listener expects to receive.  Support: Core")
    tls: Optional[IoK8sNetworkingGatewayV1GatewaySpecListenersInnerTls] = None
    __properties: ClassVar[List[str]] = ["allowedRoutes", "hostname", "name", "port", "protocol", "tls"]

    @field_validator('hostname')
    def hostname_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^(\*\.)?[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$", value):
            raise ValueError(r"must validate the regular expression /^(\*\.)?[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$/")
        return value

    @field_validator('name')
    def name_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$", value):
            raise ValueError(r"must validate the regular expression /^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$/")
        return value

    @field_validator('protocol')
    def protocol_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^[a-zA-Z0-9]([-a-zA-Z0-9]*[a-zA-Z0-9])?$|[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\/[A-Za-z0-9]+$", value):
            raise ValueError(r"must validate the regular expression /^[a-zA-Z0-9]([-a-zA-Z0-9]*[a-zA-Z0-9])?$|[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\/[A-Za-z0-9]+$/")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of IoK8sNetworkingGatewayV1GatewaySpecListenersInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of allowed_routes
        if self.allowed_routes:
            _dict['allowedRoutes'] = self.allowed_routes.to_dict()
        # override the default output from pydantic by calling `to_dict()` of tls
        if self.tls:
            _dict['tls'] = self.tls.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of IoK8sNetworkingGatewayV1GatewaySpecListenersInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "allowedRoutes": IoK8sNetworkingGatewayV1GatewaySpecListenersInnerAllowedRoutes.from_dict(obj["allowedRoutes"]) if obj.get("allowedRoutes") is not None else None,
            "hostname": obj.get("hostname"),
            "name": obj.get("name"),
            "port": obj.get("port"),
            "protocol": obj.get("protocol"),
            "tls": IoK8sNetworkingGatewayV1GatewaySpecListenersInnerTls.from_dict(obj["tls"]) if obj.get("tls") is not None else None
        })
        return _obj



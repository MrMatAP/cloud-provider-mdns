# coding: utf-8

"""
    Kubernetes CRD Swagger

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from k8s_gateway_api.models.io_k8s_networking_gateway_v1_http_route_spec_rules_inner_backend_refs_inner_filters_inner_request_redirect_path import IoK8sNetworkingGatewayV1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirectPath
from typing import Optional, Set
from typing_extensions import Self

class IoK8sNetworkingGatewayV1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect(BaseModel):
    """
    RequestRedirect defines a schema for a filter that responds to the request with an HTTP redirection.  Support: Core
    """ # noqa: E501
    hostname: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=253)]] = Field(default=None, description="Hostname is the hostname to be used in the value of the `Location` header in the response. When empty, the hostname in the `Host` header of the request is used.  Support: Core")
    path: Optional[IoK8sNetworkingGatewayV1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirectPath] = None
    port: Optional[Annotated[int, Field(le=65535, strict=True, ge=1)]] = Field(default=None, description="Port is the port to be used in the value of the `Location` header in the response.  If no port is specified, the redirect port MUST be derived using the following rules:  * If redirect scheme is not-empty, the redirect port MUST be the well-known   port associated with the redirect scheme. Specifically \"http\" to port 80   and \"https\" to port 443. If the redirect scheme does not have a   well-known port, the listener port of the Gateway SHOULD be used. * If redirect scheme is empty, the redirect port MUST be the Gateway   Listener port.  Implementations SHOULD NOT add the port number in the 'Location' header in the following cases:  * A Location header that will use HTTP (whether that is determined via   the Listener protocol or the Scheme field) _and_ use port 80. * A Location header that will use HTTPS (whether that is determined via   the Listener protocol or the Scheme field) _and_ use port 443.  Support: Extended")
    scheme: Optional[StrictStr] = Field(default=None, description="Scheme is the scheme to be used in the value of the `Location` header in the response. When empty, the scheme of the request is used.  Scheme redirects can affect the port of the redirect, for more information, refer to the documentation for the port field of this filter.  Note that values may be added to this enum, implementations must ensure that unknown values will not cause a crash.  Unknown values here must result in the implementation setting the Accepted Condition for the Route to `status: False`, with a Reason of `UnsupportedValue`.  Support: Extended")
    status_code: Optional[StrictInt] = Field(default=302, description="StatusCode is the HTTP status code to be used in response.  Note that values may be added to this enum, implementations must ensure that unknown values will not cause a crash.  Unknown values here must result in the implementation setting the Accepted Condition for the Route to `status: False`, with a Reason of `UnsupportedValue`.  Support: Core", alias="statusCode")
    __properties: ClassVar[List[str]] = ["hostname", "path", "port", "scheme", "statusCode"]

    @field_validator('hostname')
    def hostname_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$", value):
            raise ValueError(r"must validate the regular expression /^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$/")
        return value

    @field_validator('scheme')
    def scheme_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['http', 'https']):
            raise ValueError("must be one of enum values ('http', 'https')")
        return value

    @field_validator('status_code')
    def status_code_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set([301, 302]):
            raise ValueError("must be one of enum values (301, 302)")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of IoK8sNetworkingGatewayV1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of path
        if self.path:
            _dict['path'] = self.path.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of IoK8sNetworkingGatewayV1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirect from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "hostname": obj.get("hostname"),
            "path": IoK8sNetworkingGatewayV1HTTPRouteSpecRulesInnerBackendRefsInnerFiltersInnerRequestRedirectPath.from_dict(obj["path"]) if obj.get("path") is not None else None,
            "port": obj.get("port"),
            "scheme": obj.get("scheme"),
            "statusCode": obj.get("statusCode") if obj.get("statusCode") is not None else 302
        })
        return _obj


